# FIXTURE
Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций. Код в фикстуре может делать все, что вам необходимо. Вы можете использовать Fixtures, чтобы получить набор данных для тестирования. Вы можете использовать Fixtures, чтобы получить систему в известном состоянии перед запуском теста. Fixtures также используются для получения данных для нескольких тестов.


```python
    import pytest
    
    @pytest.fixture()
	def some_data():
		"""Return answer to ultimate question."""
		return 42
		
	def test_some_data(some_data):
		"""Use fixture return value in a test."""
		assert some_data == 42
```
пример функции - фикстуры возвращающей значение

Декоратор `@pytest.fixture()` используется, чтобы сообщить pytest, что функция является фикстурой. Когда вы включаете имя фикстуры в список параметров тестовой функции, pytest знает, как запустить её перед запуском теста. Фикстуры могут выполнять работу, а могут возвращать данные в тестовую функцию.

Тест `test_some_data()` имеет в качестве параметра имя фикстуры `some_data`. pytest определит это и найдет фикстуру с таким названием. Наименование значимо в pytest. pytest будет искать в модуле теста фикстуру с таким именем. Он также будет искать в файле _conftest.py_, если не найдет его в этом.


Независимо от других смысловых значений, в pytest и в этой книге test fixtures относятся к механизму, который обеспечивает pytest, чтобы отделить код “подготовка к (getting ready for)” и “очистка после (cleaning up after)” от ваших тестовых функций.






```python
    import pytest    
    import tasks    
    from tasks import Task    
    
    @pytest.fixture()    
    def tasks_db(tmpdir):        
	    """Подключение к БД перед тестами, отключение после."""        
	    
	    # Setup : start db        
	    tasks.start_tasks_db(str(tmpdir), 'tiny')        
	    
	    yield  # здесь происходит тестирование        
	    
	    # Teardown : stop db        
	    tasks.stop_tasks_db()
```

Значение _tmpdir_ не является строкой — это объект, который представляет каталог. Однако он реализует`__str__`, поэтому мы можем использовать `str()`, чтобы получить строку для передачи в `start_tasks_db()`. Пока мы все еще используем "tiny" для TinyDB.


  

Функция fixture запускается перед тестами, которые ее используют. Однако, если в функции есть _yield_, то там произойдёт остановка, контроль передастся тестам и выполняется следующая за _yield_ строка после завершения тестов. Поэтому подумайте о коде над _yield_ как о «setup», а о коде после _yield_ как о «teardown». Код после _yield_ «teardown» будет выполняться независимо от того, что происходит во время тестов. Мы не возвращаем данные с выходом в этомй фикстуре. Но вы можете.


Когда я разрабатываю fixtures, мне необходимо видеть, что работает и когда. К счастью, pytest предоставляет такой флаг для командной строки, `-- setup-show`, который делает именно это:

```bash
pytest --setup-show test_add.py -k valid_id
============================= test session starts =============================

collected 3 items / 2 deselected

test_add.py
SETUP    S tmpdir_factory
        SETUP    F tmpdir (fixtures used: tmpdir_factory)
        SETUP    F tasks_db (fixtures used: tmpdir)
        func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, 
                tmpdir, tmpdir_factory).
        TEARDOWN F tasks_db
        TEARDOWN F tmpdir
TEARDOWN S tmpdir_factory

=================== 1 passed, 2 deselected in 0.18 seconds ====================
```

  

Наш тест находится посередине, а pytest обозначил часть SETUP и TEARDOWN для каждой фикстуры. Начиная с `test_add_returns_valid_id`, вы видите, что `tmpdir` работал перед тестом. И до этого `tmpdir_factory`. По-видимому, `tmpdir` использует его как фикстуру.

  

**F** и **S** перед именами фикстур указывают область. **F** для области действия и **S** для области сеанса.

Fixtures являются отличным местом хранения данных для тестирования. Вы можете вернуть всё что угодно.

Что произойдет, если assert (или exception) случится в fixture?

Происходит пара вещей. Трассировка стека правильно показывает, что assert произошёл в функции фикстуры. Кроме того, `test_other_data` сообщается не как **FAIL**, а как **ERROR**. Это серьёзное различие. Если тест вдруг терпит неудачу, вы знаете, что сбой произошел в самом тесте, а не зависит от какой то фикстуры.


одну из главных причин использования fixtures: чтобы сфокусировать тест на том, что вы на самом деле тестируете, а не на том, что вы должны были сделать, чтобы подготовиться к тесту. Мне нравится использовать комментарии для GIVEN/WHEN/THEN и пытаться протолкнуть как можно больше данных (GIVEN) в фикстуры по двум причинам. Во-первых, это делает тест более читаемым и, следовательно, более ремонтопригодным. Во-вторых, assert или exception в фикстуре приводит к ошибке (ERROR), в то время как assert или exception в тестовой функции приводит к ошибке (FAIL).

## Спецификация областей(Scope) Fixture

  

Фикстуры включают в себя необязательный параметр под названием **scope**, который определяет, как часто фикстура получает setup и teardown. Параметр _scope_ для `@pytest.fixture()` может иметь значения функции, класса, модуля или сессии. _Scope_ по умолчанию — это функция. Настройки tasks_db и все фикстуры пока не определяют область. Таким образом, они являются функциональными фикстурами.

Ниже приведено краткое описание каждого значения _Scope_:

  

- _scope='function'_
    
      
    
    Выполняется один раз для каждой функции теста. Часть setup запускается перед каждым тестом с помощью fixture. Часть teardown запускается после каждого теста с использованием fixture. Это область используемая по умолчанию, если параметр scope не указан.
    
      
    
- _scope='class'_
    
      
    
    Выполняется один раз для каждого тестового класса, независимо от количества тестовых методов в классе.
    
      
    
- _scope='module'_
    
      
    
    Выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций или методов или других фикстур при использовании модуля.
    
      
    
- _scope='session'_
    
      
    
    Выполняется один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, используют один вызов setup и teardown.



Область(scope) определяется с помощью фикстуры. Я знаю, что это очевидно из кода, но это важный момент, чтобы убедиться, что вы полностью грокаете (_Прим переводчика_: **грокать** — скорее всего автор имеет ввиду термин из романа Роберта Хайнлайна "Чужак в стране чужой". Приблизительное значение "глубоко и интуитивно понимать"). Область(scope) задается в определении фикстуры, а не в месте её вызова. Тестовые функции, которые используют фикстуру, не контролируют, как часто устанавливается(SETUP) и срывается(TEARDOWN) фикстура.

  

Фикстуры могут зависеть только от других фикстур из той же или более расширенной области(scope). Таким образом, function scope fixture может зависеть от других function scope fixture (по умолчанию и используется в проекте Tasks до сих пор). function scope fixture также может зависеть от класса, модуля и фикстур области сеанса, но в обратном порядке — никогда.

### Specifying Fixtures with usefixtures

  

До сих пор, если вы хотели, чтобы тест использовал фикстуру, то вы помещали её в список параметров. Кроме того, можно отметить тест или класс с помощью `@pytest.mark.usefixtures('fixture1', 'fixture2')`. _usefixtures_ принимает строку, состоящую из списка фикстур, разделенных запятыми. Это не особо имеет смысл делать с тестовыми функциями — это просто дольше набирать текст. Но это хорошо работает для тестовых классов:

Использование _usefixtures_ почти то же самое, что указание имени фикстуры в списке параметров метода теста. Единственное отличие состоит в том, что тест может использовать возвращаемое значение фикстуры, только если оно указано в списке параметров. Тест, использующий фикстуру из-за использования _usefixtures_, не может использовать возвращаемое значение фикстуры.


  

## Использование autouse для Fixtures That Always Get Used (которые используются непрерывно)

  

До сих пор в этой главе все фикстуры, используемые тестами, были обертками тестов (или использовали _usefixtures_ для этого одного примера класса). Однако вы можете использовать _autouse=True_, чтобы фикстура работала постоянно. Это хорошо работает для кода, который вы хотите запустить в определенное время, но тесты на самом деле не зависят от состояния системы или данных из фикстуры.

(!) Используйте фикстуры как декораторы, если у вас нет действительно большой причины не делать этого.

  

## Переименование Fixtures

  

Название фикстур, перечисленные в списке параметров тестов и других фикстур, использующих их, обычно совпадает с именем функции фикстуры. Однако, _pytest_ позволяет вам переименовывать фикстуры с параметром name в `@pytest.fixture()`:


```python
@pytest.fixture(name=fixname)
```

таким образом дальше будет ссылаться по имени фикстуры fixname

Если вам нужно выяснить, где определена фикструа, следует добавить параметр 

```python
pytest --fixtures
```
 и дать ему имя файла для теста. В нем перечислены все фикстуры, доступные для теста, в том числе те, которые были переименованы


## Параметризация Фикстур

```bash
@pytest.fixture(params=tasks_to_try)
```

Если установить `--verbose` или флаг `-v` при запуске в pytest параметризованных тестов или параметризованных фикстур, pytest присваивает мена разным прогонам на основе значения параметризации. И поскольку значения уже являются строками, это отлично работает.



Реализация pytest fixture достаточно гибкая, чтобы использовать фикстуры, такие как _building blocks_, для создания тестового _setup_ и _teardown_, а также для смены различных фрагментов системы (например, замена Mongo для TinyDB). Поскольку фикстуры настолько гибкие, я использую их в значительной степени, чтобы как можно больше настроить мои тесты на фикстуры.





## Использование tmpdir и tmpdir_factory

  

Если вы тестируете что-то, что считывает, записывает или изменяет файлы, вы можете использовать tmpdir для создания файлов или каталогов, используемых одним тестом, и вы можете использовать `tmpdir_factory`, когда хотите настроить каталог для нескольких тестов.

  

Фикстура `tmpdir` имеет область действия функции (function scope), и фикстура `tmpdir_factory` имеет область действия сеанса (session scope). Любой отдельный тест, которому требуется временный каталог или файл только для одного теста, может использовать `tmpdir`. Это также верно для фикстуры, которая настраивает каталог или файл, которые должны быть воссозданы для каждой тестовой функции.


Значение, возвращаемое из `tmpdir`, является объектом типа [`py.path.local.1`](https://py.readthedocs.io/en/latest/path.html) это кажется все, что нам нужно для временных каталогов и файлов. Тем не менее, есть одна хитрость. Поскольку фикстура `tmpdir` определена как область действия функции (_function scope_), `tmpdir` нельзя использовать для создания папок или файлов, которые должны быть доступны дольше, чем одна тестовая функция. Для фикстур с областью видимости, отличной от функции (класс, модуль, сеанс), доступен `tmpdir_factory`.

Фикстура `tmpdir_factory` очень похоже на `tmpdir`, но имеет другой интерфейс. Как описано в разделе «Спецификация областей(Scope) Fixture», на стр. 56, фикстуры функциональной области запускаются один раз для каждой тестовой функции, фикстуры модульной области запускаются один раз на модуль, фикстуры класса один раз для каждого класса, и тесты проверки области работают один раз за сеанс. Таким образом, ресурсы, созданные в записях области сеанса, имеют срок службы всего сеанса.

```python
def test_tmpdir_factory(tmpdir_factory):
    # вы должны начать с создания каталога. a_dir действует как 
    # объект, возвращенный из фикстуры tmpdir
    a_dir = tmpdir_factory.mktemp('mydir')

    # base_temp будет родительским каталогом 'mydir' вам не нужно 
    # использовать getbasetemp(), чтобы   
    # показать, что он доступен
    base_temp = tmpdir_factory.getbasetemp()
    print('base:', base_temp)

    # остальная часть этого теста выглядит так же, 
    # как в Примере ' test_tmpdir ()', за исключением того, 
    # что я использую a_dir вместо tmpdir

    a_file = a_dir.join('something.txt')
    a_sub_dir = a_dir.mkdir('anything')
    another_file = a_sub_dir.join('something_else.txt')

    a_file.write('contents may settle during shipping')
    another_file.write('something different')

    assert a_file.read() == 'contents may settle during shipping'
    assert another_file.read() == 'something different'
```


Первая строка использует `mktemp('mydir')` для создания каталога и сохраняет его в `a_dir`. Для остальной части функции можно использовать `a_dir` так же, как `tmpdir`, возвращенный из фикстуры `tmpdir`.

  

Во второй строке примера `tmpdir_factory` функция `getbasetemp()` возвращает базовый каталог, используемый для данного сеанса. Оператор _print_ в примере нужен, чтобы можно было посмотреть каталог в вашей системе.

  

Этот базовый каталог зависит от системы и пользователя, и `pytest - NUM` изменяется для каждого сеанса с увеличеннием `NUM`. Базовый каталог остается один после сеанса. pytest очищает его, и в системе остаются только самые последние несколько временных базовых каталогов, что отлично, если вам приспичит проверить файлы после тестового запуска.

  

Вы также можете указать свой собственный базовый каталог, если вам нужно с помощью `pytest --basetemp=mydir`

  

### Использование временных каталогов для других областей

  

Мы получаем временные каталоги и файлы области **сеанса** из фикстуры `tmpdir_factory`, а каталоги и файлы области **функции** из фикстуры `tmpdir`. Но как насчет других областей? Что делать, если нам нужен временный каталог области видимости модуля или класса? Чтобы сделать это, мы создаем другую фикстуру области нужного размерчика и для этого следует использовать `tmpdir_factory`.

  

Например, предположим, что у нас есть модуль, полный тестов, и многие из них должны иметь возможность читать некоторые данные из файла _json_. Мы смогли положить фикстуру объема модуля в сам модуль, или в _conftest.py_ файл, который настраивает файл данных следующим образом:

```python

"""Demonstrate tmpdir_factory."""

import json
import pytest

@pytest.fixture(scope='module')
def author_file_json(tmpdir_factory):
    """Пишем некоторых авторов в файл данных."""
    python_author_data = {
        'Ned': {'City': 'Boston'},
        'Brian': {'City': 'Portland'},
        'Luciano': {'City': 'Sau Paulo'}
    }

    file = tmpdir_factory.mktemp('data').join('author_file.json')
    print('file:{}'.format(str(file)))

    with file.open('w') as f:
        json.dump(python_author_data, f)
    return file
```


Фикстура `author_file_json()` создает временный каталог с именем _data_ и создает файл с именем _author_file.json_ в каталоге данных. Затем записывает словарь `python_author_data` как _json_. Поскольку это фикстура области модуля, json-файл будет создан только один раз для каждого модуля, использующего тест:



## Использование pytestconfig

  

С помощью встроенной фикстуры pytestconfig вы можете управлять тем, как pytest работает с аргументами и параметрами командной строки, файлами конфигурации, плагинами и каталогом, из которого вы запустили pytest. Фикстура pytestconfig является ярлыком для request.config, и иногда упоминается в документации pytest как "_the pytest config object_"(объект конфигурации pytest).

  

Чтобы узнать, как работает _pytestconfig_, вы можете посмотреть, как добавить пользовательский параметр командной строки и прочитать значение параметра из теста. Прочитать значение параметров командной строки вы сможете непосредственно из pytestconfig, но чтобы добавить параметр и проанализировать его, вам нужно добавить функцию-ловушку (hook). Функции _hook_, которые я более подробно описываю в Главе 5, "Плагины", на стр. 95, являются еще одним способом управления поведением pytest и часто используются в плагинах. Однако добавление пользовательской опции командной строки и чтение ее из _pytestconfig_ достаточно широко распространено, поэтому я хочу осветить это здесь.

  

Мы будем использовать _pytest hook_ `pytest_addoption`, чтобы добавить несколько параметров к параметрам, уже доступным в командной строке pytest:


```python
def pytest_addoption(parser):
    parser.addoption("--myopt", action="store_true",
                     help="some boolean option")
    parser.addoption("--foo", action="store", default="bar",
                     help="foo: bar or baz")
```

  

Добавление параметров командной строки через `pytest_addoption` должно выполняться через плагины или в файле **conftest.py** расположенного в верхней части структуры каталога проекта. Вы не должны делать это в тестовом подкаталоге.

```python
import pytest

def test_option(pytestconfig):
    print('"foo" set to:', pytestconfig.getoption('foo'))
    print('"myopt" set to:', pytestconfig.getoption('myopt'))
```


## Using cache

  

Обычно мы, тестировщики, думаем, что каждый тест максимально независим от других тестов. Следует убедиться, что не закрались зависимости учёта порядка. Хотелось бы иметь возможность запустить или перезапустить любой тест в любом порядке и получить тот же результат. Кроме того, надо, чтобы сеансы тестирования были повторяемыми и не изменяли поведение на основе предыдущих сеансов тестирования.

  

Однако иногда передача информации с одного тестового сеанса в другой может быть весьма полезной. Когда мы хотим передать информацию в будущие тестовые сессии, мы можем сделать это с помощью встроенной фикстуры `cache`.

  

Фикстура `cache` предназначена для хранения информации об одном тестовом сеансе и получения её в следующем. Отличным примером использования полномочий `cache` для пользы дела является встроенная функциональность `--last-failed` и`--failed-first`. Давайте посмотрим, как данные для этих флагов хранятся в кэше.

  

Вот текст справки для опций `--last-failed` и`--failed-first`, а также несколько параметров `cache`:




  

Если вы запустите их снова с флагом `--ff` или `--failed-first`, то тесты, которые завершились неудачей ранее, будут выполнены первыми, а затем и весь сеанс:


Или вы можете использовать `--lf` или `--last-failed`, чтобы просто запустить тесты, которые провалились в прошлый раз:


```bash
pytest -q "test_few_failures.py::<full_test_name_with_parameters>"
```  

Если вы не хотите копипастить_(copy/paste_) или приключилось несколько неудачных случаев, которые вы хотели бы перезапустить, то `--lf` намного проще. И если вы действительно отлаживаете сбой теста, еще один флаг, который может облегчить ситуацию, `--showlocals`, или `-l` для краткости:



Для того, чтобы оставить в памяти, что тест не смог в прошлый раз, есть маленькая хитрость. pytest хранит информацию об ошибке теста из последнего тестового сеанса и вы можете просмотреть сохраненную информацию с помощью `--cache-show`:

```bash
$ pytest --cache-show
===================== test session starts ======================
------------------------- cache values -------------------------
cache/lastfailed contains:
   {'test_few_failures.py::test_a[1e+25-1e+23-1.1e+25]': True}
================= no tests ran in 0.00 seconds =================


$ cat .cache/v/cache/lastfailed
{
   "test_few_failures.py::test_a[1e+25-1e+23-1.1e+25]": true
}

```

Ключ `--clear-cache` позволяет очистить кэш перед сеансом.



## Использование capsys

  

Фикстура `capsys builtin` обеспечивает две функциональные возможности: позволяет получить stdout и stderr из некоторого кода, и временно отключить захват вывода. Давайте посмотрим на получение stdout и stderr.

```python
def test_greeting(capsys):
    greeting('Earthling')
    out, err = capsys.readouterr()
    assert out == 'Hi, Earthling\n'
    assert err == ''
```


_pytest_ обычно захватывает выходные данные тестов и тестируемого кода. В том числе инструкции _print_. Захваченный вывод отображается для отказов тестов только после завершения полного тестового сеанса. Параметр `-s` отключает эту функцию, и выходные данные отправляются в stdout во время выполнения тестов. Обычно это отлично работает, так как это выходные данные из неудачных тестов, которые необходимо увидеть для отладки сбоев. Тем не менее, вы можете позволить каким то выходным данным сделать его через захват вывода pytest по умолчанию, чтобы напечатать отдельные вещи, не печатая все. Вы можете сделать это с _capsys_. Вы можете использовать `capsys.disabled()`, чтобы временно пропустить вывод через механизм захвата.

## Использование monkeypatch

  

"monkey patch" — это динамическая модификация класса или модуля во время выполнения. Во время тестирования "monkey patching" — это удобный способ взять на себя часть среды выполнения тестируемого кода и заменить либо входные зависимости, либо выходные зависимости объектами или функциями, которые более удобны для тестирования. Встроенная фикстура `monkeypatch` позволяет сделать это в контексте одного теста. И когда тест заканчивается, независимо от того, пройден он или нет, оригинал восстанавливается, отменяя все изменения патча. Все это очень запутано, пока мы не перейдем к некоторым примерам. После изучения API мы рассмотрим, как monkeypatch используется в тестовом коде.

  

Фикстура `monkeypatch` обеспечивает следующие функции:

  

- `setattr(target, name, value=<notset>, raising=True)`: Установить атрибут.
- `delattr(target, name=<notset>, raising=True)`: Удалить атрибут.
- `setitem(dic, name, value)`: Задать запись в словаре.
- `delitem(dic, name, raising=True)`: Удалить запись в словаре.
- `setenv(name, value, prepend=None)`: Задать переменную окружения .
- `delenv(name, raising=True)`: Удалите переменную окружения.
- `syspath_prepend(path)`: Начало пути в sys.путь, который является списком папок для импорта Python.
- `chdir(path)`: Изменить текущий рабочий каталог.

  

Параметр `raising` указывает pytest, следует ли создавать исключение, если элемент еще не существует. Параметр `prepend` для `setenv()` может быть символом. Если он установлен, значение переменной среды будет изменено на значение `+ prepend + <old value>`.

  

Чтобы увидеть monkeypatch в действии, давайте посмотрим на код, который пишет dot-файл конфигурации. Поведение некоторых программ может быть изменено с помощью настроек и значений, заданных в dot-файле в домашнем каталоге пользователя.

## Использование doctest_namespace

  

Модуль _doctest_ является частью стандартной библиотеки Python и позволяет помещать небольшие примеры кода функции в _docstrings_ и тестировать их, чтобы убедиться, что они работают. Вы можете использовать pytest для поиска и запуска тестов _doctest_ в коде Python с помощью флага `--doctest-modules`. С встроенной фикстурой `doctest_namespace`, вы можете создать фикстуру с _autouse_, чтобы добавить символы в пространстве имен _pytest_ используя во время работы doctest тесты. Это позволяет docstrings быть гораздо более читаемым.


## Использование recwarn

  

Встроенная фикстура `recwarn` используется для проверки предупреждений, генерируемых тестируемым кодом. В Python вы можете добавлять предупреждения, которые очень похожи на утверждения, но используются для случаев, при которых не нужно останавливать выполнение. Например, предположим, что мы хотим прекратить поддерживать функцию, которую нам хотелось бы никогда не добавлять в пакет, но пришлось включить для других пользователей. Мы можем поместить предупреждение в код и оставить его там для пары выпусков:



https://habr.com/ru/articles/448782/

# Установка
==Все это, конечно должно быть для докера==




## linux


```
$ pip3 install -U virtualenv
$ python3 -m virtualenv venv
$ source venv/bin/activate
$ pip install pytest
```


## windows
```
C:\> pip3 install -U virtualenv
C:\> python3 -m virtualenv venv
C:\> venv\Scripts\activate.bat
(venv) C:\> pip install pytest
```
# Запуск

```
$ pytest --help
usage: pytest [options] [file_or_dir] [file_or_dir] [...]
...
```

При запуске без аргументов pytest рекурсивно проверяет все катологи - ищет файлы начниающиеся "test_*" или заканчивающиеся на "_test"

Для запуска конкретных тестов - передаем папку или тест аргументом

## Запуск одного теста

```
pytest -v tasks/test_four.py::test_asdict
```

Запуск только функции test_asdict из файла tasks/test_fout.py






# Соглашения об именах

- Тестовые файлы должны быть названы `test_<something>.py` или `<something>_test.py`.
- Методы и функции тестирования должны быть названы `test_<something>`.
- Тестовые классы должны быть названы `Test<Something>`.

==еще будут новые соглашения==

# Результаты

по одной точке для каждой тестовой функции или метода. Точки предназначены только для прохождения тестов. Failures (сбоев), errors (ошибок), skips (пропусков), xfails, и xpasses обозначаются с F, E, s, x, и Х, соответственно.

- PASSED (.): Тест выполнен успешно.
- FAILED (F): Тест не выполнен успешно (или XPASS + strict).
- SKIPPED (s): Тест был пропущен. Вы можете заставить pytest пропустить тест, используя декораторы `@pytest.mark.skip()` или `pytest.mark.skipif()`, обсуждаемые в разделе пропуск тестов, на стр. 34.
- xfail (x): Тест не должен был пройти, был запущен и провалился. Вы можете принудительно указать pytest, что тест должен завершиться неудачей, используя декоратор `@pytest.mark.xfail()`, описанный в маркировках тестов как ожидающий неудачу, на стр. 37.
- XPASS (X): Тест не должен был пройти, был запущен и прошел!..
- ERROR (E): Исключение произошло за пределами функции тестирования, либо в фикстуре, обсуждается в главе 3, pytest Фикстуры, на стр. 49, или в hook function, обсуждается в главе 5, Плагины, на странице 95.

==таблица для всех возможных==
==добавление своих, кастомных==




# Опции
  
### --collect-only

Параметр `--collect-only` показывает, какие тесты будут выполняться с заданными параметрами и конфигурацией.
 - Не запускает тесты, а только выводит все файлы и функции которые будут использоваться

### -k EXPRESSION

  

Параметр `-k` позволяет использовать выражение для определения функций тестирования.

  

Весьма мощная опция! Её можно использовать как ярлык для запуска отдельного теста, если имя уникально, или запустить набора тестов, которые имеют общий префикс или суффикс в их именах. Предположим, вы хотите запустить тесты `test_asdict()` и `test_defaults()`

```bash
pytest -k 'defaults or asdict'
```

Параметр `-k` позволяет передать выражение для выполнения тестов, имена которых заданы выражением в качестве подстроки имени теста. Для создания сложных выражений можно использовать `and`, `or` и `not` в выражении. Например, мы можем запустить все функции с именем `_raises`
```bash
pytest -v -k _raises
```


### -m MARKEXPR

  

Маркеры-один из лучших способов пометить подмножество тестовых функций для совместного запуска. В качестве примера, один из способов запустить `test_replace()` и `test_member_access()`, даже если они находятся в отдельных файлах, это пометить их. Можно использовать любое имя маркера. Допустим, вы хотите использовать `run_these_please`. Отметим тесты, используя декоратор `@pytest.mark.run_these_please`, вот так:

Нужно отмечать тестов декоратором
```
@pytest.mark.<mark_name>
```
и тогда дальше сможем вызывать такие тесты через параметр -m

- Поддерживает операторы and , or, non

```python
@pytest.mark.smoke    
def test_list_raises():        """list() должно возникнуть исключение с неправильным типом param."""
	with pytest.raises(TypeError):
		tasks.list_tasks(owner=123)
			
@pytest.mark.get    
@pytest.mark.smoke    
def test_get_raises():        """get() должно возникнуть исключение с неправильным типом param."""        
	with pytest.raises(TypeError):       
		tasks.get(task_id='123')
```

Помечаем одну функцию марировкой smoke и другую smoke and get

pytest включает в себя несколько полезных встроенных маркеров: `skip`, `skipif`, и `xfail`
Маркеры `skip` и `skipif` позволяют пропускать тесты, которые не нужно выполнять.

```python

@pytest.mark.skipif(tasks.__version__ < '0.2.0',                        reason='not supported until version 0.2.0')
def test_unique_id_1():        
	"""Вызов unique_id () дважды должен возвращать разные числа."""
		id_1 = tasks.unique_id()
		id_2 = tasks.unique_id()
		assert id_1 != id_2
```

Выражение, которое мы передаем в `skipif()`, может быть любым допустимым выражением Python. В этом конкретном, нашем случае, мы проверяем версию пакета. Мы включили причины как в _skip_, так и в _skipif_. Это не требуется в _skip_, но это требуется в _skipif_.

С помощью маркеров `skip` и `skipif` тест даже не выполняется, если он пропущен. С помощью маркера `xfail` мы указываем pytest запустить тестовую функцию, но ожидаем, что она потерпит неудачу.

==т.е. можем писать не только положительные тесты==



### -x, --exitfirst

  

Нормальным поведением _pytest_ является запустить все тесты, которые он найдет. Если тестовая функция обнаружит сбой _assert_ или _exception_, выполнение этого теста останавливается, и тест завершается ошибкой. И тогда _pytest_ запускает следующий тест. По большей части, это то что надо. Однако, особенно при отладке проблемы, мешает сразу всей тестовой сессии, когда тест не является правильным.

==Остановка всего тестрана при появлении первого падения теста==


### --maxfail=num

  

Параметр `-x` приводит к остановке после первого отказа теста. Если вы хотите, чтобы некоторые число сбоев было допущено, но не целая тонна, используйте параметр `--maxfail`, чтобы указать, сколько ошибок допускается получить

==странный параметр, пока не понятно зачем его вообще использовать ==

### --tb=no

Отключение трассировки 
- Ускоряет прогон на большом количестве

```bash
pytest --tb=long
``` 
покажет вам наиболее исчерпывающий и информативный traceback. 

```bash
pytest --tb=auto
``` 
покажет вам длинную версию для первого и последнего _tracebacks_, если у вас есть несколько сбоев. Это поведение по умолчанию.
```bash
pytest --tb=native
``` 

покажет вам стандартную библиотеку _traceback_ без дополнительной информации.

### -s and --capture=method | Методы захвата


  

Флаг `-s` позволяет печатать операторы — или любой другой вывод, который обычно печатается в _stdout_, чтобы фактически быть напечатаным в стандартном выводе во время выполнения тестов. Это сокращенный вариант для `--capture=no`. Смысл в том, что обычно выходные данные захватываются во всех тестах. Неудачные тесты будут выводиться после того, как тест будет протекать в предположении, что выход поможет вам понять, что что то пошло не так. Параметр `-s` или `--capture=no` отключает захват выходных данных.

==ниче не понял, надо смотреть==


  

Другой вариант, который может помочь вам обойтись без операторов печати в вашем коде,`-l/--showlocals`, который распечатывает локальные переменные в тесте, если тест терпит неудачу.

  

Другие опции метода захвата `--capture=fd` и `--capture=sys`. — Опция `--capture=sys` заменяет `sys.stdout/stderr` в mem-файлах. Опция `--capture=fd` указывает файловые дескрипторы 1 и 2 на временный файл.


### -lf, --last-failed

  

При сбое одного или нескольких тестов способ выполнения только неудачных тестов полезен для отладки. Просто используйте `--lf` и вы готовы к отладке:


### -v, --verbose

  

Опция `-v/--verbose` предоставляет более развернутую информацию по итогам. Наиболее очевидным отличием является то, что каждый тест получает свою собственную строку, а имя теста и результат прописываются вместо точки.


### -q, --quiet

  

Опция `-q/--quiet` противоположна `-v/--verbose`; она сокращает объем информации в отчете. Мне нравится использовать его в сочетании с `--tb=line`, в этом случае выводятся только неудавшиеся строки любых неудачных тестов.

### -l, --showlocals

  

При использовании параметра `-l/--showlocals` локальные переменные и их значения отображаются вместе с `tracebacks` для неудачных тестов.

# Организация тестов

## Мысли
- unit  - модульные тесты
- functional - функциональные
- smoke - смок тесты, что в первую очередь пойдут
- 

Функциональные и модульные тесты разделены на собственные каталоги. Это произвольное решение и не обязательно. Однако организация тестовых файлов в несколько каталогов позволяет легко запускать подмножество тестов. Мне нравится разделять функциональные и модульные тесты, потому что функциональные тесты должны ломаться, только если мы намеренно изменяя функциональность системы, в то время как модульные тесты могут сломаться во время рефакторинга или изменения реализации.
## pytest.ini
Файл `pytest.ini` не является обязательным. Он содержит общую конфигурацию pytest для всего проекта. В вашем проекте должно быть не более одного из них. Он может содержать директивы, которые изменяют поведение pytest, например, настрйки списка параметров, которые всегда будут использоваться. Вы узнаете все о `pytest.ini` в главе 6 «Конфигурация» на стр. 113.

## conftest.ini
Файл conftest.py также является необязательным. Он считается pytest как “local plugin” и может содержать hook functions и fixtures. _Hook functions_ являются способом вставки кода в часть процесса выполнения pytest для изменения работы pytest. Fixtures — это setup и teardown функции, которые выполняются до и после тестовых функций и могут использоваться для представления ресурсов и данных, используемых тестами.


## Тестовые классы

  

Тестовые классы — это способ группировать тесты, которые по смыслу группируются вместе.  
Вот пример:

  

```python
    class TestUpdate():
        """Тест ожидаемых исключений с tasks.update()."""
        def test_bad_id(self):            
	        """non-int id должен поднять excption."""     
	        with pytest.raises(TypeError):             
		        tasks.update(task_id={'dict instead': 1},                             task=tasks.Task())        
		def test_bad_task(self):            
			"""A non-Task task должен поднять excption."""            
			with pytest.raises(TypeError):                
				tasks.update(task_id=1, task='not a task')
```


Чтобы запустить только этот класс, сделайте так же, как мы сделали с функциями и добавьте `::`, затем имя класса в параметр вызова:

```bash
(venv33) ...\bopytest-code\code\ch2\tasks_proj>pytest -v tests/func/test_api_exceptions.py::TestUpdate
```

Если вы не хотите запускать весь тестовый класс, а только один метод — просто добавьте ещё раз `::` и имя метода:

```bash
pytest -v ests/func/test_api_exceptions.py::TestUpdate::test_bad_id
```

# Assert
[документация из doc.python](https://doc.pytest.org/en/latest/example/reportingdemo.html)


С помощью pytest вы можете использовать assert <выражение> с любым выражением. Если выражение будет вычисляться как False, когда оно будет преобразовано в bool, тест завершится с ошибкой.

pytest включает функцию, называемую assert rewriting, которая перехватывает assert calls и заменяет их тем, что может рассказать вам больше о том, почему ваши утверждения не удались.

```python
def test_add_raises():        """add() должно возникнуть исключение с неправильным типом param."""
	with pytest.raises(TypeError):
		tasks.add(task='not a Task object')
```

В `test_add_raises()`, с `pytest.raises(TypeError)`: оператор сообщает, что все, что находится в следующем блоке кода, должно вызвать исключение TypeError.



# fixture

Мы можем определить fixture для инициализации базы данных перед тестом и очистки после теста:

```python
@pytest.fixture(autouse=True)
	def initialized_tasks_db(tmpdir):
	    """Connect to db before testing, disconnect after."""        
	    # Setup : start db
	    tasks.start_tasks_db(str(tmpdir), 'tiny')
	    
	    yield  # здесь происходит тестирование        
	    
	    # Teardown : stop db        
	    tasks.stop_tasks_db()
```

`autouse=True`, используемый в нашем тесте, показывает, что все тесты в этом файле будут использовать fixture

- Код перед `yield` выполняется перед каждым тестом
- код после `yield` выполняется после теста.
- При желании yield может возвращать данные в тест. ==как==




# Параметризированное тестирование

Передача отдельных значений через функцию и проверка выходных данных, чтобы убедиться в их правильности, является распространенным явлением в тестировании программного обеспечения. Однако единичного вызова функции с одним набором значений и одной проверкой правильности недостаточно для полной проверки большинства функций. Параметризованное тестирование-это способ отправить несколько наборов данных через один и тот же тест и иметь отчет pytest, если какой-либо из наборов не удался.

`@pytest.mark.parametrize(argnames, argvalues)` для передачи множества данных через один и тот же тест, например:

  

> **ch2/tasks_proj/tests/func/`test_add_variety.py`**

  

```python
    @pytest.mark.parametrize('task',
							[Task('sleep', done=True),
							 Task('wake', 'brian'),
							 Task('breathe', 'BRIAN', True),
							 Task('exercise', 'BrIaN', False)])
	def test_add_2(task):
		"""Демонстрирует параметризацию с одним параметром."""
		task_id = tasks.add(task)
		t_from_db = tasks.get(task_id)
		assert equivalent(t_from_db, task)
```

- Можно передавать задачи как кортежи вместо 'task' по кол-ву параметров


# FIXTURE
Fixtures — это функции, выполняемые pytest до (а иногда и после) фактических тестовых функций. Код в фикстуре может делать все, что вам необходимо. Вы можете использовать Fixtures, чтобы получить набор данных для тестирования. Вы можете использовать Fixtures, чтобы получить систему в известном состоянии перед запуском теста. Fixtures также используются для получения данных для нескольких тестов.


```python
    import pytest
    
    @pytest.fixture()
	def some_data():
		"""Return answer to ultimate question."""
		return 42
		
	def test_some_data(some_data):
		"""Use fixture return value in a test."""
		assert some_data == 42
```
пример функции - фикстуры возвращающей значение

Декоратор `@pytest.fixture()` используется, чтобы сообщить pytest, что функция является фикстурой. Когда вы включаете имя фикстуры в список параметров тестовой функции, pytest знает, как запустить её перед запуском теста. Фикстуры могут выполнять работу, а могут возвращать данные в тестовую функцию.

Тест `test_some_data()` имеет в качестве параметра имя фикстуры `some_data`. pytest определит это и найдет фикстуру с таким названием. Наименование значимо в pytest. pytest будет искать в модуле теста фикстуру с таким именем. Он также будет искать в файле _conftest.py_, если не найдет его в этом.


Независимо от других смысловых значений, в pytest и в этой книге test fixtures относятся к механизму, который обеспечивает pytest, чтобы отделить код “подготовка к (getting ready for)” и “очистка после (cleaning up after)” от ваших тестовых функций.






```python
    import pytest    
    import tasks    
    from tasks import Task    
    
    @pytest.fixture()    
    def tasks_db(tmpdir):        
	    """Подключение к БД перед тестами, отключение после."""        
	    
	    # Setup : start db        
	    tasks.start_tasks_db(str(tmpdir), 'tiny')        
	    
	    yield  # здесь происходит тестирование        
	    
	    # Teardown : stop db        
	    tasks.stop_tasks_db()
```

Значение _tmpdir_ не является строкой — это объект, который представляет каталог. Однако он реализует`__str__`, поэтому мы можем использовать `str()`, чтобы получить строку для передачи в `start_tasks_db()`. Пока мы все еще используем "tiny" для TinyDB.


  

Функция fixture запускается перед тестами, которые ее используют. Однако, если в функции есть _yield_, то там произойдёт остановка, контроль передастся тестам и выполняется следующая за _yield_ строка после завершения тестов. Поэтому подумайте о коде над _yield_ как о «setup», а о коде после _yield_ как о «teardown». Код после _yield_ «teardown» будет выполняться независимо от того, что происходит во время тестов. Мы не возвращаем данные с выходом в этомй фикстуре. Но вы можете.


Когда я разрабатываю fixtures, мне необходимо видеть, что работает и когда. К счастью, pytest предоставляет такой флаг для командной строки, `-- setup-show`, который делает именно это:

```bash
pytest --setup-show test_add.py -k valid_id
============================= test session starts =============================

collected 3 items / 2 deselected

test_add.py
SETUP    S tmpdir_factory
        SETUP    F tmpdir (fixtures used: tmpdir_factory)
        SETUP    F tasks_db (fixtures used: tmpdir)
        func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, 
                tmpdir, tmpdir_factory).
        TEARDOWN F tasks_db
        TEARDOWN F tmpdir
TEARDOWN S tmpdir_factory

=================== 1 passed, 2 deselected in 0.18 seconds ====================
```

  

Наш тест находится посередине, а pytest обозначил часть SETUP и TEARDOWN для каждой фикстуры. Начиная с `test_add_returns_valid_id`, вы видите, что `tmpdir` работал перед тестом. И до этого `tmpdir_factory`. По-видимому, `tmpdir` использует его как фикстуру.

  

**F** и **S** перед именами фикстур указывают область. **F** для области действия и **S** для области сеанса.

Fixtures являются отличным местом хранения данных для тестирования. Вы можете вернуть всё что угодно.

Что произойдет, если assert (или exception) случится в fixture?

Происходит пара вещей. Трассировка стека правильно показывает, что assert произошёл в функции фикстуры. Кроме того, `test_other_data` сообщается не как **FAIL**, а как **ERROR**. Это серьёзное различие. Если тест вдруг терпит неудачу, вы знаете, что сбой произошел в самом тесте, а не зависит от какой то фикстуры.


одну из главных причин использования fixtures: чтобы сфокусировать тест на том, что вы на самом деле тестируете, а не на том, что вы должны были сделать, чтобы подготовиться к тесту. Мне нравится использовать комментарии для GIVEN/WHEN/THEN и пытаться протолкнуть как можно больше данных (GIVEN) в фикстуры по двум причинам. Во-первых, это делает тест более читаемым и, следовательно, более ремонтопригодным. Во-вторых, assert или exception в фикстуре приводит к ошибке (ERROR), в то время как assert или exception в тестовой функции приводит к ошибке (FAIL).

## Спецификация областей(Scope) Fixture

  

Фикстуры включают в себя необязательный параметр под названием **scope**, который определяет, как часто фикстура получает setup и teardown. Параметр _scope_ для `@pytest.fixture()` может иметь значения функции, класса, модуля или сессии. _Scope_ по умолчанию — это функция. Настройки tasks_db и все фикстуры пока не определяют область. Таким образом, они являются функциональными фикстурами.

Ниже приведено краткое описание каждого значения _Scope_:

  

- _scope='function'_
    
      
    
    Выполняется один раз для каждой функции теста. Часть setup запускается перед каждым тестом с помощью fixture. Часть teardown запускается после каждого теста с использованием fixture. Это область используемая по умолчанию, если параметр scope не указан.
    
      
    
- _scope='class'_
    
      
    
    Выполняется один раз для каждого тестового класса, независимо от количества тестовых методов в классе.
    
      
    
- _scope='module'_
    
      
    
    Выполняется один раз для каждого модуля, независимо от того, сколько тестовых функций или методов или других фикстур при использовании модуля.
    
      
    
- _scope='session'_
    
      
    
    Выполняется один раз за сеанс. Все методы и функции тестирования, использующие фикстуру области сеанса, используют один вызов setup и teardown.



Область(scope) определяется с помощью фикстуры. Я знаю, что это очевидно из кода, но это важный момент, чтобы убедиться, что вы полностью грокаете (_Прим переводчика_: **грокать** — скорее всего автор имеет ввиду термин из романа Роберта Хайнлайна "Чужак в стране чужой". Приблизительное значение "глубоко и интуитивно понимать"). Область(scope) задается в определении фикстуры, а не в месте её вызова. Тестовые функции, которые используют фикстуру, не контролируют, как часто устанавливается(SETUP) и срывается(TEARDOWN) фикстура.

  

Фикстуры могут зависеть только от других фикстур из той же или более расширенной области(scope). Таким образом, function scope fixture может зависеть от других function scope fixture (по умолчанию и используется в проекте Tasks до сих пор). function scope fixture также может зависеть от класса, модуля и фикстур области сеанса, но в обратном порядке — никогда.

### Specifying Fixtures with usefixtures

  

До сих пор, если вы хотели, чтобы тест использовал фикстуру, то вы помещали её в список параметров. Кроме того, можно отметить тест или класс с помощью `@pytest.mark.usefixtures('fixture1', 'fixture2')`. _usefixtures_ принимает строку, состоящую из списка фикстур, разделенных запятыми. Это не особо имеет смысл делать с тестовыми функциями — это просто дольше набирать текст. Но это хорошо работает для тестовых классов:

Использование _usefixtures_ почти то же самое, что указание имени фикстуры в списке параметров метода теста. Единственное отличие состоит в том, что тест может использовать возвращаемое значение фикстуры, только если оно указано в списке параметров. Тест, использующий фикстуру из-за использования _usefixtures_, не может использовать возвращаемое значение фикстуры.


  

## Использование autouse для Fixtures That Always Get Used (которые используются непрерывно)

  

До сих пор в этой главе все фикстуры, используемые тестами, были обертками тестов (или использовали _usefixtures_ для этого одного примера класса). Однако вы можете использовать _autouse=True_, чтобы фикстура работала постоянно. Это хорошо работает для кода, который вы хотите запустить в определенное время, но тесты на самом деле не зависят от состояния системы или данных из фикстуры.

(!) Используйте фикстуры как декораторы, если у вас нет действительно большой причины не делать этого.

  

## Переименование Fixtures

  

Название фикстур, перечисленные в списке параметров тестов и других фикстур, использующих их, обычно совпадает с именем функции фикстуры. Однако, _pytest_ позволяет вам переименовывать фикстуры с параметром name в `@pytest.fixture()`:


```python
@pytest.fixture(name=fixname)
```

таким образом дальше будет ссылаться по имени фикстуры fixname

Если вам нужно выяснить, где определена фикструа, следует добавить параметр 

```python
pytest --fixtures
```
 и дать ему имя файла для теста. В нем перечислены все фикстуры, доступные для теста, в том числе те, которые были переименованы


## Параметризация Фикстур

```bash
@pytest.fixture(params=tasks_to_try)
```

Если установить `--verbose` или флаг `-v` при запуске в pytest параметризованных тестов или параметризованных фикстур, pytest присваивает мена разным прогонам на основе значения параметризации. И поскольку значения уже являются строками, это отлично работает.



Реализация pytest fixture достаточно гибкая, чтобы использовать фикстуры, такие как _building blocks_, для создания тестового _setup_ и _teardown_, а также для смены различных фрагментов системы (например, замена Mongo для TinyDB). Поскольку фикстуры настолько гибкие, я использую их в значительной степени, чтобы как можно больше настроить мои тесты на фикстуры.





## Использование tmpdir и tmpdir_factory

  

Если вы тестируете что-то, что считывает, записывает или изменяет файлы, вы можете использовать tmpdir для создания файлов или каталогов, используемых одним тестом, и вы можете использовать `tmpdir_factory`, когда хотите настроить каталог для нескольких тестов.

  

Фикстура `tmpdir` имеет область действия функции (function scope), и фикстура `tmpdir_factory` имеет область действия сеанса (session scope). Любой отдельный тест, которому требуется временный каталог или файл только для одного теста, может использовать `tmpdir`. Это также верно для фикстуры, которая настраивает каталог или файл, которые должны быть воссозданы для каждой тестовой функции.


Значение, возвращаемое из `tmpdir`, является объектом типа [`py.path.local.1`](https://py.readthedocs.io/en/latest/path.html) это кажется все, что нам нужно для временных каталогов и файлов. Тем не менее, есть одна хитрость. Поскольку фикстура `tmpdir` определена как область действия функции (_function scope_), `tmpdir` нельзя использовать для создания папок или файлов, которые должны быть доступны дольше, чем одна тестовая функция. Для фикстур с областью видимости, отличной от функции (класс, модуль, сеанс), доступен `tmpdir_factory`.

Фикстура `tmpdir_factory` очень похоже на `tmpdir`, но имеет другой интерфейс. Как описано в разделе «Спецификация областей(Scope) Fixture», на стр. 56, фикстуры функциональной области запускаются один раз для каждой тестовой функции, фикстуры модульной области запускаются один раз на модуль, фикстуры класса один раз для каждого класса, и тесты проверки области работают один раз за сеанс. Таким образом, ресурсы, созданные в записях области сеанса, имеют срок службы всего сеанса.

```python
def test_tmpdir_factory(tmpdir_factory):
    # вы должны начать с создания каталога. a_dir действует как 
    # объект, возвращенный из фикстуры tmpdir
    a_dir = tmpdir_factory.mktemp('mydir')

    # base_temp будет родительским каталогом 'mydir' вам не нужно 
    # использовать getbasetemp(), чтобы   
    # показать, что он доступен
    base_temp = tmpdir_factory.getbasetemp()
    print('base:', base_temp)

    # остальная часть этого теста выглядит так же, 
    # как в Примере ' test_tmpdir ()', за исключением того, 
    # что я использую a_dir вместо tmpdir

    a_file = a_dir.join('something.txt')
    a_sub_dir = a_dir.mkdir('anything')
    another_file = a_sub_dir.join('something_else.txt')

    a_file.write('contents may settle during shipping')
    another_file.write('something different')

    assert a_file.read() == 'contents may settle during shipping'
    assert another_file.read() == 'something different'
```


Первая строка использует `mktemp('mydir')` для создания каталога и сохраняет его в `a_dir`. Для остальной части функции можно использовать `a_dir` так же, как `tmpdir`, возвращенный из фикстуры `tmpdir`.

  

Во второй строке примера `tmpdir_factory` функция `getbasetemp()` возвращает базовый каталог, используемый для данного сеанса. Оператор _print_ в примере нужен, чтобы можно было посмотреть каталог в вашей системе.

  

Этот базовый каталог зависит от системы и пользователя, и `pytest - NUM` изменяется для каждого сеанса с увеличеннием `NUM`. Базовый каталог остается один после сеанса. pytest очищает его, и в системе остаются только самые последние несколько временных базовых каталогов, что отлично, если вам приспичит проверить файлы после тестового запуска.

  

Вы также можете указать свой собственный базовый каталог, если вам нужно с помощью `pytest --basetemp=mydir`

  

### Использование временных каталогов для других областей

  

Мы получаем временные каталоги и файлы области **сеанса** из фикстуры `tmpdir_factory`, а каталоги и файлы области **функции** из фикстуры `tmpdir`. Но как насчет других областей? Что делать, если нам нужен временный каталог области видимости модуля или класса? Чтобы сделать это, мы создаем другую фикстуру области нужного размерчика и для этого следует использовать `tmpdir_factory`.

  

Например, предположим, что у нас есть модуль, полный тестов, и многие из них должны иметь возможность читать некоторые данные из файла _json_. Мы смогли положить фикстуру объема модуля в сам модуль, или в _conftest.py_ файл, который настраивает файл данных следующим образом:

```python

"""Demonstrate tmpdir_factory."""

import json
import pytest

@pytest.fixture(scope='module')
def author_file_json(tmpdir_factory):
    """Пишем некоторых авторов в файл данных."""
    python_author_data = {
        'Ned': {'City': 'Boston'},
        'Brian': {'City': 'Portland'},
        'Luciano': {'City': 'Sau Paulo'}
    }

    file = tmpdir_factory.mktemp('data').join('author_file.json')
    print('file:{}'.format(str(file)))

    with file.open('w') as f:
        json.dump(python_author_data, f)
    return file
```


Фикстура `author_file_json()` создает временный каталог с именем _data_ и создает файл с именем _author_file.json_ в каталоге данных. Затем записывает словарь `python_author_data` как _json_. Поскольку это фикстура области модуля, json-файл будет создан только один раз для каждого модуля, использующего тест:



## Использование pytestconfig

  

С помощью встроенной фикстуры pytestconfig вы можете управлять тем, как pytest работает с аргументами и параметрами командной строки, файлами конфигурации, плагинами и каталогом, из которого вы запустили pytest. Фикстура pytestconfig является ярлыком для request.config, и иногда упоминается в документации pytest как "_the pytest config object_"(объект конфигурации pytest).

  

Чтобы узнать, как работает _pytestconfig_, вы можете посмотреть, как добавить пользовательский параметр командной строки и прочитать значение параметра из теста. Прочитать значение параметров командной строки вы сможете непосредственно из pytestconfig, но чтобы добавить параметр и проанализировать его, вам нужно добавить функцию-ловушку (hook). Функции _hook_, которые я более подробно описываю в Главе 5, "Плагины", на стр. 95, являются еще одним способом управления поведением pytest и часто используются в плагинах. Однако добавление пользовательской опции командной строки и чтение ее из _pytestconfig_ достаточно широко распространено, поэтому я хочу осветить это здесь.

  

Мы будем использовать _pytest hook_ `pytest_addoption`, чтобы добавить несколько параметров к параметрам, уже доступным в командной строке pytest:


```python
def pytest_addoption(parser):
    parser.addoption("--myopt", action="store_true",
                     help="some boolean option")
    parser.addoption("--foo", action="store", default="bar",
                     help="foo: bar or baz")
```

  

Добавление параметров командной строки через `pytest_addoption` должно выполняться через плагины или в файле **conftest.py** расположенного в верхней части структуры каталога проекта. Вы не должны делать это в тестовом подкаталоге.

```python
import pytest

def test_option(pytestconfig):
    print('"foo" set to:', pytestconfig.getoption('foo'))
    print('"myopt" set to:', pytestconfig.getoption('myopt'))
```


## Using cache

  

Обычно мы, тестировщики, думаем, что каждый тест максимально независим от других тестов. Следует убедиться, что не закрались зависимости учёта порядка. Хотелось бы иметь возможность запустить или перезапустить любой тест в любом порядке и получить тот же результат. Кроме того, надо, чтобы сеансы тестирования были повторяемыми и не изменяли поведение на основе предыдущих сеансов тестирования.

  

Однако иногда передача информации с одного тестового сеанса в другой может быть весьма полезной. Когда мы хотим передать информацию в будущие тестовые сессии, мы можем сделать это с помощью встроенной фикстуры `cache`.

  

Фикстура `cache` предназначена для хранения информации об одном тестовом сеансе и получения её в следующем. Отличным примером использования полномочий `cache` для пользы дела является встроенная функциональность `--last-failed` и`--failed-first`. Давайте посмотрим, как данные для этих флагов хранятся в кэше.

  

Вот текст справки для опций `--last-failed` и`--failed-first`, а также несколько параметров `cache`:




  

Если вы запустите их снова с флагом `--ff` или `--failed-first`, то тесты, которые завершились неудачей ранее, будут выполнены первыми, а затем и весь сеанс:


Или вы можете использовать `--lf` или `--last-failed`, чтобы просто запустить тесты, которые провалились в прошлый раз:


```bash
pytest -q "test_few_failures.py::<full_test_name_with_parameters>"
```  

Если вы не хотите копипастить_(copy/paste_) или приключилось несколько неудачных случаев, которые вы хотели бы перезапустить, то `--lf` намного проще. И если вы действительно отлаживаете сбой теста, еще один флаг, который может облегчить ситуацию, `--showlocals`, или `-l` для краткости:



Для того, чтобы оставить в памяти, что тест не смог в прошлый раз, есть маленькая хитрость. pytest хранит информацию об ошибке теста из последнего тестового сеанса и вы можете просмотреть сохраненную информацию с помощью `--cache-show`:

```bash
$ pytest --cache-show
===================== test session starts ======================
------------------------- cache values -------------------------
cache/lastfailed contains:
   {'test_few_failures.py::test_a[1e+25-1e+23-1.1e+25]': True}
================= no tests ran in 0.00 seconds =================


$ cat .cache/v/cache/lastfailed
{
   "test_few_failures.py::test_a[1e+25-1e+23-1.1e+25]": true
}

```

Ключ `--clear-cache` позволяет очистить кэш перед сеансом.



## Использование capsys

  

Фикстура `capsys builtin` обеспечивает две функциональные возможности: позволяет получить stdout и stderr из некоторого кода, и временно отключить захват вывода. Давайте посмотрим на получение stdout и stderr.

```python
def test_greeting(capsys):
    greeting('Earthling')
    out, err = capsys.readouterr()
    assert out == 'Hi, Earthling\n'
    assert err == ''
```


_pytest_ обычно захватывает выходные данные тестов и тестируемого кода. В том числе инструкции _print_. Захваченный вывод отображается для отказов тестов только после завершения полного тестового сеанса. Параметр `-s` отключает эту функцию, и выходные данные отправляются в stdout во время выполнения тестов. Обычно это отлично работает, так как это выходные данные из неудачных тестов, которые необходимо увидеть для отладки сбоев. Тем не менее, вы можете позволить каким то выходным данным сделать его через захват вывода pytest по умолчанию, чтобы напечатать отдельные вещи, не печатая все. Вы можете сделать это с _capsys_. Вы можете использовать `capsys.disabled()`, чтобы временно пропустить вывод через механизм захвата.

## Использование monkeypatch

  

"monkey patch" — это динамическая модификация класса или модуля во время выполнения. Во время тестирования "monkey patching" — это удобный способ взять на себя часть среды выполнения тестируемого кода и заменить либо входные зависимости, либо выходные зависимости объектами или функциями, которые более удобны для тестирования. Встроенная фикстура `monkeypatch` позволяет сделать это в контексте одного теста. И когда тест заканчивается, независимо от того, пройден он или нет, оригинал восстанавливается, отменяя все изменения патча. Все это очень запутано, пока мы не перейдем к некоторым примерам. После изучения API мы рассмотрим, как monkeypatch используется в тестовом коде.

  

Фикстура `monkeypatch` обеспечивает следующие функции:

  

- `setattr(target, name, value=<notset>, raising=True)`: Установить атрибут.
- `delattr(target, name=<notset>, raising=True)`: Удалить атрибут.
- `setitem(dic, name, value)`: Задать запись в словаре.
- `delitem(dic, name, raising=True)`: Удалить запись в словаре.
- `setenv(name, value, prepend=None)`: Задать переменную окружения .
- `delenv(name, raising=True)`: Удалите переменную окружения.
- `syspath_prepend(path)`: Начало пути в sys.путь, который является списком папок для импорта Python.
- `chdir(path)`: Изменить текущий рабочий каталог.

  

Параметр `raising` указывает pytest, следует ли создавать исключение, если элемент еще не существует. Параметр `prepend` для `setenv()` может быть символом. Если он установлен, значение переменной среды будет изменено на значение `+ prepend + <old value>`.

  

Чтобы увидеть monkeypatch в действии, давайте посмотрим на код, который пишет dot-файл конфигурации. Поведение некоторых программ может быть изменено с помощью настроек и значений, заданных в dot-файле в домашнем каталоге пользователя.

## Использование doctest_namespace

  

Модуль _doctest_ является частью стандартной библиотеки Python и позволяет помещать небольшие примеры кода функции в _docstrings_ и тестировать их, чтобы убедиться, что они работают. Вы можете использовать pytest для поиска и запуска тестов _doctest_ в коде Python с помощью флага `--doctest-modules`. С встроенной фикстурой `doctest_namespace`, вы можете создать фикстуру с _autouse_, чтобы добавить символы в пространстве имен _pytest_ используя во время работы doctest тесты. Это позволяет docstrings быть гораздо более читаемым.


## Использование recwarn

  

Встроенная фикстура `recwarn` используется для проверки предупреждений, генерируемых тестируемым кодом. В Python вы можете добавлять предупреждения, которые очень похожи на утверждения, но используются для случаев, при которых не нужно останавливать выполнение. Например, предположим, что мы хотим прекратить поддерживать функцию, которую нам хотелось бы никогда не добавлять в пакет, но пришлось включить для других пользователей. Мы можем поместить предупреждение в код и оставить его там для пары выпусков:



# Плагины

## создание устанавливаемого плагина

  

Процесс обмена плагинами с другими пользователями четко определен. Даже если вы никогда не включите свой собственный плагин в PyPI, то пройдя через этот процесс, вам будет легче читать код из плагинов с открытым исходным кодом, и у вас будет больше возможностей оценить, помогут они вам или нет.

  

Было бы излишним полностью охватывать packaging и distribution пакетов Python в этой книге, так как эта тема хорошо документирована в другом месте. [Тут](http://python-packaging.readthedocs.io) и [здесь](https://www.pypa.io) и еще [здесь](https://www.ibm.com/developerworks/ru/library/os-pythonpackaging/index.html) на русском. Тем не менее, перейти от локального подключаемого модуля конфигурации, который мы создали в предыдущем разделе, к чему-то устанавливаемому с помощью pip, является несложной задачей. ,

  

Во-первых, нам нужно создать новый каталог для размещения нашего кода плагина. Неважно, как вы это называете, но, поскольку мы создаем плагин для флага «nice», давайте назовем его «pytest-nice». У нас будет два файла в этом новом каталоге: pytest_nice.py и setup.py. (Каталог тестов будет обсуждаться в разделе «Плагины тестирования» на странице.105.)


```bash
│   LICENSE
│   pytest_nice.py
│   setup.py
│
└───tests
    │   conftest.py
    │   test_nice.py
```

В `pytest_nice.py`, мы поместим точное содержимое нашего conftest.py, которое было связано с этой функцией (и извлечем его из `tasks_proj/tests/conftest.py`):

В `setup.py` нам нужен максимальноминимальный вызов `setup()`:

```python
"""Setup для pytest-nice plugin."""

from setuptools import setup

setup(
    name='pytest-nice',
    version='0.1.0',
    description='Плагин Pytest, чтобы включить FAILURE into OPPORTUNITY',
    url='https://место/где/содержится/информация/на/этот/пакет',
    author='Ваше имя',
    author_email='your_email@somewhere.com',
    license='proprietary',
    py_modules=['pytest_nice'],
    install_requires=['pytest'],
    entry_points={'pytest11': ['nice = pytest_nice', ], },
)


```

  

Вы можете включить еще какие то параметры для `setup()`; а тут у нас только обязательные поля. Поле версии является версией этого плагина. И это целиком зависит от вас, когда вы поднимаете версию. Поле URL обязательно для заполнения. Вы можете оставить его пустым, но вы получите предупреждение. Поля `author` и `author_email` можно заменить на `maintainer` и `maintainer_email`, но одна из этих пар должна быть там. Поле `license`-лицензия представляет собой короткое текстовое поле. Это может быть одна из многих лицензий с открытым исходным кодом, ваше имя или компании, или что-то подходящее для вас. Запись `py_modules` перечисляет `pytest_nice` как наш единственный модуль для этого плагина. Хотя это список, и вы можете включить более одного модуля, если бы у меня было больше одного, я бы использовал пакет и поместил все модули в один каталог.

  

До сих пор все параметры `setup()` являются стандартными и используются для всех инсталляторов Python. Частью, которая отличается для плагинов Pytest, является параметр `entry_points`. Мы перечислили `entry_points={'pytest11': ['nice = pytest_nice', ], },.` Функция `entry_points` является стандартной для `setuptools`, но pytest11 специальный идентификатор, который ищет pytest. В этой строке мы сообщаем pytest, что `nice`-это имя нашего плагина, а `pytest_nice`-имя модуля, в котором живет наш плагин. Если бы мы использовали пакет, наша запись здесь была бы:

  

Я еще не говорил о файле `README.rst`. Некоторая форма README является требованием setuptools. Если вы пропустите его, вы получите это: